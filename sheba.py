#! /usr/bin/env python
##############################
#   Program: sheba.py
#
##############################
#   Author: J. Asplet
##############################
#   A python program to act as a wrapper to sheba.
#   It read, filters, and trims SAC files from a
#   provided list of events and passes each event
#   to sheba for shear wave splitting analysis.
#   When the analysis is complete the program will
#   collect the output files for each event and it
#   will concatenate them together into a summary
#   output file!
#   This program is designed to be run from the command line (using python sheba.py)
#   If you want to run sheba for single stations or interactivly use parts of this program, then use the "module" version interact_sheba.py
#
#
##############################
#   Import Statements
##############################
#   Standard Packages - all freely available
import os.path
import obspy as ob
import obspy.taup
import subprocess as sub
from subprocess import CalledProcessError
import time
import timeit
from multiprocessing import Pool, current_process
from functools import partial
import contextlib
from glob import glob
from Windower import WindowPicker
import argparse
from wrapper import Interface
############################################################################################
# Define Functions and Classes
############################################################################################
def tidyup(path,phase,outfile,outdir):
    """
    Function to collect .final_result files output from Sheba into the Run directory. Results are written in the SBD format to Sheba/Results

    path - [str]: path to the Run directory (e.g. /users/ja17375/DiscrePy/Sheba/Runs/Run_Name)
    phase - Phase that you want to collect results for
    outfile - [str]: outfile name (filename only! Path taken from Path variable)
    """
    if phase == 'SYNTH':
        fnames = glob('{}/*.final_result'.format(path))
        print('{}*.final_result'.format(path))
    else:
        fnames = glob('{}/*/{}/*final_result'.format(path,phase))
    results = []
    # print(fnames)
    for i,file in enumerate(fnames):
        print(file)
        f_stat = fnames[i].rstrip('final_result') + 'stats'

        with open(file,'r') as input, open(f_stat,'r') as stats:
             head = input.readline()
             head_s = stats.readline()
             h = head.split()
             s = head_s.split()
             # print(s)
             h.remove('%')
             s.remove('%')
             del s[0:2] ,s[-1]
             j = h.index('STAT')
             h[2],h[3:j+1]= h[j],h[2:j]

             header = ' '.join(h) + ' ' + ' '.join(s)

             for line in input.readlines():
                s = stats.readline().split() # Read the next line from the Stats file (should have the same number of lines as final_result)
                r = line.split()
                # if i == 0:
                    #'For the first file print out r
                    # print(r)
                r.remove('%')
                s.remove('%')
                del s[0:2] ,s[-1]
                r[2],r[3:j+1] = r[j],r[2:j]
                result = ' '.join(r) + ' ' + ' '.join(s)
                results.append(result)

    results.insert(0,header)
    # outdir = path.split('/')[-1]
    print('Writing Results to {} in /Users/ja17375/DiscrePy/Sheba/Results/{}'.format(outfile,outdir))
    with open('/Users/ja17375/DiscrePy/Sheba/Results/{}/{}'.format(outdir,outfile),'w') as writer:
        for r in results:
            writer.write(str(r) + '\n')

def run_synth_i(runpath,filepath):
    '''
    Self Contained Function to run sheba (DEISGNED FOR IPYTHON USE) for a set of synthetics generated by sacsplitwave
    '''
    r_dir = '/Users/ja17375/DiscrePy/Sheba/Runs/SYNTH/LowSNR'
    with open('/Users/ja17375/DiscrePy/Data/Synthetics.events','r') as reader:
        for i, line in enumerate(reader.readlines()):
            file = line.strip('\n')

            label = '{}_'.format(file.split('/')[-1])
            # print(label)
            st_id = '{}.BH?'.format(file)
            st = obspy.read(st_id)
            stat= st[0].stats.station
            #print(st)
            Event = Interface(st)
            Event.preprocess(synth=True)
            # print(r_dir)
            print(label)
            Event.write_out('SYNTH',label,path=r_dir)
            Event.sheba(stat,'SYNTH',label,path=r_dir)
     #End of loop
    tidyup(r_dir,'SYNTH','Synthetics_results.sdb')

def run_synth(runpath,filepath):
    '''
    Runs sheba for a list of file mapped in (for parallelised version).
    '''
    # print('Running')
    label = '{}_'.format(filepath.split('/')[-1])
    phase= 'SYNTH' #Empty String for phase are these are synthetics
    # print(label)
    st_id = '{}.BH?'.format(filepath)
    print(st_id)
    st = obspy.read(st_id)
    #print(st)
    Event = Interface(st)
    # print('Synthetics Used, Windows *should* be predefined')
    Event.preprocess(synth=True)
    # print(r_dir)
    print(label)
    Event.write_out('SYNTH',label,path=runpath)
    # print('{}, {}, {}, {}, False'.format(stat,phase,label,runpath))
    Event.sheba(phase,label,path=runpath,nwind=True)



def run_sheba(runpath,filepath,phases=['ScS']):
    """
    Function that holds the guts of the workflow for preparing SAC files and running sheba
    """
    #Each station SHOULD have its own directory within Data/SAC_files
    #If the data has been downloaded. So lets look for directorys that exist

    dir_path = '/'.join(filepath.split('/')[0:-1])
    # print('RP {} \n FP: {} '.format(runpath,filepath))
    if os.path.isdir(dir_path):
        #'Happy Days! The data directory exists!'
        for phase in phases:
            #print(phase)
            label = '{}'.format(filepath.split('/')[-1]) # Extract the event label STAT_DATE_TIME so I can use it to label output stremas from sheba
            # print('Label is {}'.format(label))
            st_id = '{}BH?.sac'.format(filepath)
            # st_id = '{}.BX?'.format(filepath) # .BX? for SPECFeM SYNTHETICS
            st = ob.read(st_id)
            station = st[0].stats.station
            f_check = '{}/{}/{}/{}{}_sheba.final_result'.format(runpath,station,phase,label,phase)
            # print('Fcheck is {}'.format(f_check))
            # print('{}/{}/{}/{}{}.B?E'.format(runpath,station,phase,label,phase))
            if os.path.isfile(f_check) == True: # Check if event has already been processed
                print('File has already been processed: {} '.format(f_check))
            else:
                if len(st) == 3:
                    Event = Interface(st)
                    print('Check epicentral distances')
                    # check should not be done in wrapper!
                    if Event.check_phase_dist(phase_to_check=phase) is True:
                #       To ensure that we contain the phase information completlely lets model the arrival using TauP
                        print('Modelling Traveltimes')
                        Event.model_traveltimes(phase)
                        # print('Process waveform, stat {}, phase {}, label {}'.format(station,phase,label))
                        Event.preprocess(synth=False,window=False) # If windowing is set to true then SHEBA must be called in serial mode
                        if Event.bad is True:
                            # A bad waveform that we dont want anyhting to do with, so skip it
                            pass

                        else:
                            outdir = '{}/{}/{}'.format(runpath,station,phase)
                            try:
                                Event.write_out(phase,label,path=outdir)
                            except OSError:
                                print('Directory {} writing outputs do not all exist. Initialising'.format(outdir))
                                os.makedirs(outdir)
                                # print('Label is {}. Path is {}'.format(label,path))
                                Event.write_out(phase,label,path=outdir)
                            # print('RUn sheba, stat {}, phase {}, label {}, out {}'.format(station,phase,label,outdir))
                            Event.sheba(phase,label,path=outdir,nwind=True)
                            #tidyup_by_stat(path,station,phase,label,outfile)
                    else:
                        # print('Fail, Distance ')
                        pass
                else:
                    print(' len(st) is not 3. Passing')
                    pass
    else:
        print('The directory {} does not exists'.format(dir_path))
        pass

##############################
# Begin Program
##############################
if __name__ == '__main__':
    # print(__name__)
#  Main Level, calls functions and set everything up
#  This function depends on the existence of a station list file specified by statlist and you have sac data alreayd downloaded
#  Path should point to the directory that you want the sheba processing directories to be stored under
#
#  Phases - [list]: Phases that you want to process for shear wave splitting using sheba. Traces should contain the expected arrivals. Interact sheb will loop over all phases provided and run sheba accordingly
#
#  Batch - [bool]: T- run in batch mode (multi station), using pythons multiprocessing library to improve performance. F - run for a single station
#
#  evt_sta_list - [str]: string pointing to the location of the event station list. This list should contain the a date/time and station that corresponds to the event time and station where arrivals are obseverd.
#                        This list is used to
#
# #First Indentify the possible station that we could have data for
#This way we know what directory paths to look in for the sac files

    #Loop over all stations in the list.
    #################### Time run #################
    start = timeit.default_timer()
    #####################################################################################
    # Setup Paths, Constants and sort out input Arguements #############
    #####################################################################################
    # Set full path to station list
    parser = argparse.ArgumentParser()
    parser.add_argument("-e","--events",action="store",required=True,help="File name for the .events file containing the filestems you want to processes")
    parser.add_argument("-r","--rundir",action="store",required=True,help="The run directory that you wish to work in")
    parser.add_argument("-p","--parallel",action="store_true",default=False,help="Swtich for whether you want sheba to run in parallel")
    parser.add_argument("-nc","--ncores",action="store",type=int,help="Number of Cores requested for a parallel job")
    parser.add_argument("-s","--syn",action="store_true",default=False,help="Indicates that the data to be processed is synthetics, which can required a slightly different treatment")
    args = parser.parse_args()

    print(args)
    # evt_list = sys.argv[1] # A .events file containing a list of filestems to al the data we want to measure
    # rundir=sys.argv[2] # The run directory that you want to house the output files
    # run_mode = sys.argv[3] # par is wanting to run in parallel, ser if running serially
    # mode=sys.argv[4] # data if using real data, syn is using synthetics
    # print(mode,type(mode))
    file_list ='/Users/ja17375/DiscrePy/Data/{}'.format(args.events)
    # echo out where I expect the staiton list to be
    print('Processing Data from the Downloaded Event List {}'.format(file_list))
    files = []
    with open(file_list,'r') as reader:
        for i, line in enumerate(reader.readlines()):
            f = line.strip('\n')
            files.append(f)
            # print(f)
        print('There are {} files to process'.format(i+1))
    # Get the user to input the outfile name they want (Phase label will be added later)
    out_pre = input('Enter SDB file name: ')
    ################### SET THE PHASES TO BE PROCESSED HERE #############################
    # phases = ['SKS','SKKS']
    phases = ['ScS']
    ######################################################################################
    ############### Run Sheba - using parallel processing with Pool ######################
    ######################################################################################
    runpath ='/Users/ja17375/DiscrePy/Sheba/Runs/{}'.format(args.rundir)
    print('Runpath is :',runpath)
    if args.syn is False:
        # runpath ='/Users/ja17375/DiscrePy/Sheba/Runs/{}'.format(rundir)
        runner = partial(run_sheba,runpath,phases=['ScS'])
        if args.parallel is True:
            print("Parallel job. {} cores requested".format(args.ncores))
            with contextlib.closing( Pool(processes = args.ncores) ) as pool:
            #           Iterate over stations in the station list.
                pool.map(runner,files)
            #               pool.map(tidyup,stations) ??? Maybe this would work???
    #       Tidy up results
            print('Sheba run complete, time to tidy up')
        else:
            print("Running Serial Job")
            #Run in serial mode (booooo)
            for file in files:
                # print(file)
                run_sheba(runpath=runpath,filepath=file)

        for phase in phases:
            """ Loop over phases process and tidyup results """
            tidy_path = '/Users/ja17375/DiscrePy/Sheba/Runs/{}'.format(args.rundir)
            outfile = '{}_{}_sheba_results.sdb'.format(out_pre,phase)
            # outdir = tidy_path.split('/')[-1]
            tidyup(tidy_path,phase,outfile,args.rundir)


    elif args.syn is True:
        phase='SYNTH'
        runner = partial(run_synth,runpath)
        # As all the synthetics files are in the same directory (They share a "station") we cannot run in parralel with all the synthetics being stored in the same directory.
        # This occurs as my sythetics are all stored under one station directory, so we cannot keep each worker looking at a different station
        # As a result, the workers trip over each other an corrupt the majority of infiles.
        print('Synthetics Run')
        print('Runpath is :',runpath)
        # with contextlib.closing( Pool(processes = 8) ) as pool:
        #           Iterate over stations in the station list.
            # pool.map(runner,files)
        for file in files:
            runner(file)
        #Tidyup results
        print('Sheba run complete, time to tidy up')
        """ Loop over phases process and tidyup results """
        tidy_path = '/Users/ja17375/DiscrePy/Sheba/Runs/{}'.format(args.rundir)
        outfile = '{}_SYNTH_sheba_results.sdb'.format(out_pre)
        # outdir = rundir.split('/')[0]
        tidyup(tidy_path,phase,outfile,args.rundir)

    # print('Sheba run complete, time to tidy up')
    ######################################################################################
    ################ Run Sheba - Serial Model ########
    ######################################################################################
    # for i,file in enumerate(files):
    #     run_sheba(file,'/Users/ja17375/DiscrePy/Sheba/Runs/Test',phases= ['SKKS'])
    #     print('Iteration: {}. File: {}'.format(i,file))

    ######################################################################################
    # End Timing of run
    ######################################################################################
    end = timeit.default_timer()
    runtime = end - start
    print('The runtime of main is {} minutes'.format(runtime/60))
# END
